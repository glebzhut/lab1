#pragma once
#include <iostream>
#include<time.h>
#include <string>
#include <vector>
#include<map>
#include<conio.h>
#include<iomanip>
#include<sstream>

using namespace std;

class DishonestDice
{
private:
    int number_of_edges;
    vector<double> chance;

    const int diffdices[6] = { 2, 4, 6, 10, 12, 20 };

    bool CheckDice(int numedge)
    {
        return numedge == 2 || numedge == 4 || numedge == 6 || numedge == 8 || numedge == 10 || numedge == 12 || numedge == 20;
    }

public:
    DishonestDice()
    {
        number_of_edges = 6;
        vector<double> ch(6);
        for (int i = 0; i < 6; i++)
        {
            double newch = 1.0 / 6;
            ch[i] = newch;
        }
        chance = ch;
    }

    DishonestDice(int numedge)
    {
        if (CheckDice(numedge))
        {
            number_of_edges = numedge;
            vector<double> ch(numedge);
            for (int i = 0; i < numedge; i++)
            {
                double newch = 1.0 / numedge;
                ch[i] = newch;
            }
            chance = ch;
        }
        else throw logic_error("Wrong number of edges: "+ to_string(numedge));
    }

    DishonestDice(int numedge, const vector<int>& stats)
    {
        if (CheckDice(numedge))
        {
            number_of_edges = numedge;
            int sum = 0;
            for (int i = 0; i < numedge; i++)
                sum += stats[i];
            chance.clear();
            for (int i = 0; i < numedge; i++)
            {
                double ch = stats[i];
                ch/= sum;
                chance.push_back(ch);
            }
        }
        else throw logic_error("Wrong number of edges: " + to_string(numedge));
    }

    void operator=(const DishonestDice& d)
    {
        number_of_edges = d.number_of_edges;
        chance = d.chance;
    }

    void AutoGenerate()
    {
        number_of_edges = diffdices[rand() % 6];
        vector<int> stats;
        for (int i = 0; i < number_of_edges; i++)
            stats.push_back(1 + rand() % 10);
        int sum = 0;
        for (int i = 0; i < number_of_edges; i++)
            sum += stats[i];
        chance.clear();
        for (int i = 0; i < number_of_edges; i++)
        {
            double ch = stats[i];
            ch /= sum;
            chance.push_back(ch);
        }
    }

    int GetNumberOfEdges() const
    {
        return number_of_edges;
    }

    vector<double> GetChance() const 
    {
        return chance;
    }
};

ostream& operator<<(ostream& s, const DishonestDice& d);
ostream& operator<<(ostream& s, const map<int, double> ch);
ostream& operator<<(ostream& s, const vector<vector<int>> tb);
template<typename T>
ostream& operator<<(ostream& s, const vector<T>& l)
{
    for (int i = 0; i < l.size() - 1; i++)
        s << setw(10) << l[i] << " ";
    s << setw(10) << l[l.size() - 1] << endl;
    return s;
}
map<int, double> GetStatistic(const vector<DishonestDice>& dices);
int EnterNumber(const string& number);
double EnterDouble(const string& number);
char EnterChar(const string& number);
string EnterString(const string& number);
DishonestDice EnterDice(const string& dice);
int AutoGenerateInt();
char AutoGenerateChar();
double AutoGenerateDouble();
string AutoGenerateString();
DishonestDice AutoGenerateDishonestDice();
bool operator==(const DishonestDice& d1, const DishonestDice& d2);

